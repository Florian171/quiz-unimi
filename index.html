<!doctype html>
<html lang="it">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Quiz di Pratica</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" rel="stylesheet">
    <link rel="icon" type="image/jpeg" href="logo.png">
    <style>
        body {
            background: #f8f9fa;
            color: #212529;
        }

        .card {
            background: #ffffff;
            border: 1px solid #dee2e6;
        }

        .form-check-label {
            cursor: pointer;
        }

        .choice {
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .choice:hover {
            background: #f8f9fa;
            border-color: #6c757d;
        }

        .choice.correct {
            border-color: #198754;
            background: #e6f4ea;
        }

        .choice.wrong {
            border-color: #dc3545;
            background: #fbeaea;
        }

        /* Fix per allineamento radio/checkbox con testo multiriga */
        .choice .card-body {
            display: flex;
            align-items: flex-start;
            gap: 0.5rem;
        }

        .choice .form-check-input {
            margin: 0;
            flex-shrink: 0;
            margin-top: 0.125rem;
            /* Piccolo offset per allineare meglio con il testo */
        }

        .choice .form-check-label {
            flex: 1;
            margin: 0;
            line-height: 1.5;
        }

        .sticky-footer {
            position: sticky;
            bottom: 0;
            background: #ffffff;
            border-top: 1px solid #dee2e6;
            padding: .75rem;
        }

        .badge-quiz {
            background: #e9ecef;
            color: #212529;
        }

        a,
        a:hover {
            color: #0d6efd;
        }

        .muted {
            color: #6c757d;
        }

        .hidden {
            display: none !important;
        }

        .progress {
            height: 10px;
        }

        .question-text {
            white-space: pre-wrap;
        }

        .pill {
            background: #e9ecef;
            border: 1px solid #ced4da;
            padding: .2rem .45rem;
            border-radius: 999px;
            font-size: .8rem;
            color: #495057;
        }

            /* Stili per la barra di navigazione numerica */
            .navigation-container {
                max-height: 120px; /* Limita l'altezza massima */
                overflow-y: auto; /* Scroll verticale se necessario */
                border: 1px solid #dee2e6;
                border-radius: 8px;
                padding: 6px; /* Ridotto da 8px per centratura più precisa */
                background: #f8f9fa;
                scroll-behavior: smooth; /* Assicura scroll smooth anche per scrollTop */
            }

            .question-numbers-grid {
                display: grid;
                grid-template-columns: repeat(auto-fill, minmax(32px, 1fr));
                gap: 4px;
                max-width: 100%;
            }

            .question-number {
                width: 32px;
                height: 32px;
                border: 1px solid #dee2e6;
                background: #f8f9fa;
                color: #6c757d;
                border-radius: 6px;
                cursor: pointer;
                transition: all 0.2s ease;
                font-size: 0.75rem;
                font-weight: 500;
                display: flex;
                align-items: center;
                justify-content: center;
            }        .question-number:hover {
            border-color: #0d6efd;
            background: #e7f3ff;
            color: #0d6efd;
        }

        .question-number.current {
            background: #0d6efd;
            border-color: #0d6efd;
            color: white;
        }

        .question-number.answered {
            background: #e9ecef;
            border-color: #6c757d;
            color: #495057;
        }

        .question-number.answered.current {
            background: #6c757d;
            border-color: #6c757d;
            color: white;
        }

        .question-number.correct {
            background: #e6f4ea;
            border-color: #198754;
            color: #198754;
        }

        .question-number.correct.current {
            background: #198754;
            border-color: #198754;
            color: white;
        }

        .question-number.wrong {
            background: #fbeaea;
            border-color: #dc3545;
            color: #dc3545;
        }

        .question-number.wrong.current {
            background: #dc3545;
            border-color: #dc3545;
            color: white;
        }

        /* Stili per le carte collassabili */
        .card-header[data-bs-toggle="collapse"] {
            transition: background-color 0.15s ease-in-out;
        }

        .card-header[data-bs-toggle="collapse"]:hover {
            background-color: #f8f9fa;
        }

        .card-header[data-bs-toggle="collapse"] .collapse-icon {
            transition: transform 0.15s ease-in-out;
        }

        .card-header[data-bs-toggle="collapse"][aria-expanded="true"] .collapse-icon {
            transform: rotate(180deg);
        }

        /* Nascondi footer su mobile */
        @media (max-width: 768px) {
            footer {
                display: none;
            }
            
            .sticky-footer {
                position: fixed; /* Fixed invece di sticky per evitare movimenti */
                bottom: 0;
                left: 0;
                right: 0;
                margin-bottom: 0;
                padding-bottom: 0.75rem;
                z-index: 1000; /* Assicura che rimanga sopra altri elementi */
            }
            
            /* Aggiungi spazio in basso per la footer fixed */
            body {
                padding-bottom: 40px; /* Ridotto per meno spazio inutile */
            }
            
            #questionCard {
                margin-bottom: 0; /* Reset margin, usiamo il padding del body */
            }

            /* Layout responsive per checkbox */
            .col-12.col-md-6 .d-flex.gap-4 {
                flex-wrap: nowrap !important;
                gap: 0.5rem !important;
                justify-content: flex-start !important;
                align-items: flex-start !important;
            }
            
            .col-12.col-md-6 .d-flex.gap-4 > .form-check {
                flex: 1 !important;
                max-width: none !important;
                font-size: 0.75rem !important;
                margin-right: 0 !important;
                margin-bottom: 0 !important;
                display: flex !important;
                align-items: flex-start !important;
            }
            
            .col-12.col-md-6 .d-flex.gap-4 > .form-check .form-check-input {
                margin-top: 0.125rem !important;
                margin-right: 0.25rem !important;
            }
            
            .col-12.col-md-6 .d-flex.gap-4 > .form-check .form-check-label {
                font-size: 0.75rem !important;
                line-height: 1.2 !important;
                white-space: normal !important;
                word-break: break-word !important;
            }
            
            /* Su schermi molto piccoli, text wrapping per le checkbox */
            @media (max-width: 480px) {
                .col-12.col-md-6 .d-flex.gap-4 > .form-check .form-check-label {
                    white-space: normal !important;
                    word-break: break-word !important;
                    line-height: 1.1 !important;
                }
            }
            
            /* Layout responsive per bottoni */
            .col-12.col-md-6 .d-flex.flex-column.flex-md-row .d-flex.gap-2 {
                flex-wrap: nowrap !important;
                gap: 0.3rem !important;
            }
            
            .col-12.col-md-6 .d-flex.flex-column.flex-md-row .d-flex.gap-2 > #btnClearSaved,
            .col-12.col-md-6 .d-flex.flex-column.flex-md-row .d-flex.gap-2 > #btnClearWrong {
                flex: 1 !important;
                max-width: none !important;
                margin-bottom: 0 !important;
                padding: 0.375rem 0.4rem !important;
                font-size: 0.8rem !important;
            }
        }

        /* Layout armonioso delle 3 checkbox opzioni quiz su mobile e desktop */
        #quizOptionsRow {
            row-gap: 0.5rem;
        }
        
        /* Mobile extra small (fino a 350px) - Tutto in colonna */
        @media (max-width: 350px) {
            #quizOptionsRow {
                flex-direction: column;
                align-items: center;
                gap: 0.6rem;
            }
            #quizOptionsRow .form-check {
                width: 100%;
                max-width: 200px;
                text-align: center;
                display: flex;
                align-items: center;
                justify-content: center;
                gap: 0.4rem;
            }
            #quizOptionsRow .form-check-label {
                font-size: 0.8rem;
            }
        }
        
        /* Mobile small (351px a 576px) - 2 sopra, 1 sotto centrata */
        @media (min-width: 351px) and (max-width: 576px) {
            #quizOptionsRow {
                flex-wrap: wrap;
                justify-content: center;
                gap: 0.75rem;
                align-content: flex-start;
            }
            #quizOptionsRow .form-check {
                flex: 0 0 45%;
                max-width: 45%;
                text-align: center;
                display: flex;
                align-items: center;
                justify-content: center;
                gap: 0.4rem;
            }
            #quizOptionsRow .form-check:nth-child(3) {
                flex: 0 0 60%;
                max-width: 60%;
                margin: 0 auto;
            }
            #quizOptionsRow .form-check-label {
                font-size: 0.85rem;
                white-space: nowrap;
            }
        }
        
        /* Mobile medium (577px a 768px) */
        @media (min-width: 577px) and (max-width: 768px) {
            #quizOptionsRow {
                flex-wrap: wrap;
                justify-content: center;
                gap: 0.6rem 1.5rem;
            }
            #quizOptionsRow .form-check {
                min-width: 130px;
                flex: 1 1 130px;
                text-align: center;
                margin-bottom: 0;
            }
        }
        
        /* Tablet e desktop */
        @media (min-width: 769px) {
            #quizOptionsRow {
                justify-content: flex-start;
                gap: 2rem;
            }
        }

        /* Stili per il modal delle scorciatoie */
        .modal-content {
            border-radius: 12px;
            border: none;
            box-shadow: 0 10px 30px rgba(0,0,0,0.15);
        }
        
        .modal-header {
            border-bottom: 1px solid #e9ecef;
            background: #f8f9fa;
            border-radius: 12px 12px 0 0;
        }
        
        kbd {
            background-color: #495057 !important;
            color: white !important;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            font-size: 0.8rem;
            font-weight: 600;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        /* Nascondi il pulsante help su mobile */
        @media (max-width: 768px) {
            #btnHelp {
                display: none !important;
            }
        }
    </style>
</head>

<body>
    <div class="container py-4">
        <div class="d-flex align-items-center justify-content-between mb-3">
            <div class="d-flex align-items-center gap-3">
                <img src="logo.png" alt="Logo" style="height:35px; width:auto; border-radius:8px; box-shadow:0 2px 8px rgba(0,0,0,0.08); margin-right: -10px;">
                <div>
                    <h1 class="h3 mb-1">Quiz di Pratica</h1>
                    <div class="muted"></div>
                </div>
            </div>
            <div>
                <span id="totalCounter" class="pill">0 domande</span>
            </div>
        </div>

        <div class="card mb-3">
            <div class="card-body">
                <div class="row g-3">
                    <div class="col-12 col-md-6">
                        <label class="form-label">Seleziona dataset</label>
                        <select id="datasetSelect" class="form-select">
                        </select>
                        <div id="datasetInfo" class="small muted mt-2"></div>
                    </div>
                    <div class="col-12 col-md-6">
                        <label class="form-label">Seleziona set</label>
                        <select id="setSelect" class="form-select">
                            <option value="all">Tutti i quiz</option>
                        </select>
                        <div id="setInfo" class="small muted mt-2"></div>
                    </div>
                </div>

                <div class="row g-3 align-items-center mt-2">
                    <div class="col-12 col-md-6">
                        <!-- Opzioni quiz -->
                        <div class="d-flex flex-wrap justify-content-center gap-3" id="quizOptionsRow">
                            <div class="form-check">
                                <input class="form-check-input" type="checkbox" id="shuffleCheckbox">
                                <label class="form-check-label" for="shuffleCheckbox">
                                    <i class="fas fa-random"></i> Ordine casuale
                                </label>
                            </div>
                            <div class="form-check">
                                <input class="form-check-input" type="checkbox" id="showErrorsCheckbox">
                                <label class="form-check-label" for="showErrorsCheckbox">
                                    <i class="fas fa-search"></i> Navbar colorata
                                </label>
                            </div>
                            <div class="form-check">
                                <input class="form-check-input" type="checkbox" id="highlightAnswerCheckbox">
                                <label class="form-check-label" for="highlightAnswerCheckbox">
                                    <i class="fas fa-highlighter"></i> Evidenzia risposta
                                </label>
                            </div>
                        </div>
                    </div>
                    <div class="col-12 col-md-6 text-md-end">
                        <div class="d-flex flex-column flex-md-row gap-2 justify-content-md-end">
                            <div class="d-flex gap-2">
                                <button id="btnClearSaved" class="btn btn-outline-warning"><i class="fas fa-trash"></i> Quiz Salvati</button>
                                <button id="btnClearWrong" class="btn btn-outline-danger"><i class="fas fa-trash"></i> Quiz Sbagliati</button>
                            </div>
                            <button id="btnStart" class="btn btn-primary">Inizia</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div id="quizArea" class="hidden">
            <div class="d-flex align-items-center justify-content-between mb-2">
                <div class="small">
                    <span id="quizBadge" class="badge rounded-pill badge-quiz me-2"></span>
                    <span id="progressLabel" class="muted"></span>
                </div>
                <div class="w-50">
                    <div class="progress">
                        <div id="progressBar" class="progress-bar" role="progressbar" style="width: 0%"></div>
                    </div>
                </div>
            </div>

            <!-- Barra di navigazione numerica -->
            <div id="navigationBar" class="mb-3">
                <div class="navigation-container">
                    <div class="question-numbers-grid" id="questionNumbers">
                        <!-- I numeri delle domande verranno inseriti qui dinamicamente -->
                    </div>
                </div>
            </div>

            <div id="questionCard" class="card mb-3">
                <div class="card-body">
                    <div id="qText" class="question-text mb-3"></div>
                    <div id="choices" class="vstack gap-2"></div>
                </div>
            </div>

            <div class="sticky-footer d-flex justify-content-between">
                <div class="d-flex align-items-center gap-2">
                    <button id="btnPrev" class="btn btn-secondary" disabled>Back</button>
                    <button id="btnHelp" class="btn btn-outline-info btn-sm" data-bs-toggle="tooltip" data-bs-placement="top" title="Scorciatoie da tastiera">
                        <i class="fas fa-keyboard"></i>
                    </button>
                </div>
                <div>
                    <button id="btnSave" class="btn btn-outline-primary me-2"><i class="fas fa-save"></i></button>
                    <button id="btnCheck" class="btn btn-secondary me-2">Check</button>
                    <button id="btnNext" class="btn btn-primary">Next</button>
                </div>
            </div>
        </div>

        <!-- Modal per le scorciatoie da tastiera -->
        <div class="modal fade" id="helpModal" tabindex="-1" aria-labelledby="helpModalLabel" aria-hidden="true">
            <div class="modal-dialog modal-dialog-centered">
                <div class="modal-content">
                    <div class="modal-header">
                        <h5 class="modal-title" id="helpModalLabel">
                            <i class="fas fa-keyboard me-2"></i>Scorciatoie da Tastiera
                        </h5>
                        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                    </div>
                    <div class="modal-body">
                        <div class="row g-3">
                            <div class="col-12">
                                <h6 class="text-primary mb-2"><i class="fas fa-mouse-pointer me-1"></i> Navigazione</h6>
                                <div class="d-flex justify-content-between align-items-center mb-1">
                                    <span>Domanda precedente</span>
                                    <kbd class="bg-secondary">P</kbd>
                                </div>
                                <div class="d-flex justify-content-between align-items-center mb-1">
                                    <span>Domanda successiva</span>
                                    <kbd class="bg-secondary">N</kbd>
                                </div>
                                <div class="d-flex justify-content-between align-items-center mb-3">
                                    <span>Controlla risposta</span>
                                    <kbd class="bg-secondary">C</kbd>
                                </div>
                            </div>
                            <div class="col-12">
                                <h6 class="text-success mb-2"><i class="fas fa-check-circle me-1"></i> Selezione Risposte</h6>
                                <div class="d-flex justify-content-between align-items-center mb-1">
                                    <span>Seleziona prima risposta</span>
                                    <kbd class="bg-secondary">1</kbd>
                                </div>
                                <div class="d-flex justify-content-between align-items-center mb-1">
                                    <span>Seleziona seconda risposta</span>
                                    <kbd class="bg-secondary">2</kbd>
                                </div>
                                <div class="d-flex justify-content-between align-items-center mb-1">
                                    <span>Seleziona terza risposta</span>
                                    <kbd class="bg-secondary">3</kbd>
                                </div>
                                <div class="d-flex justify-content-between align-items-center">
                                    <span>Seleziona quarta risposta</span>
                                    <kbd class="bg-secondary">4</kbd>
                                </div>
                            </div>
                        </div>
                        <div class="alert alert-info mt-3 mb-0">
                            <small><i class="fas fa-info-circle me-1"></i>
                            Le scorciatoie funzionano solo quando premute singolarmente, senza modificatori (Ctrl, Alt, Shift).
                            </small>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div id="resultArea" class="hidden">
            <div class="card mb-3">
                <div class="card-body">
                    <h2 class="h5 mb-3">Risultati</h2>
                    <div id="resultSummary" class="mb-2"></div>
                    <div class="alert alert-info mb-0">
                        <strong><i class="fas fa-lightbulb"></i> Suggerimento:</strong> Le domande sbagliate sono ora disponibili nel menu "Seleziona set" come "Domande Sbagliate" per il ripasso mirato.
                    </div>
                </div>
            </div>
            <div id="reviewList" class="vstack gap-2"></div>
        </div>

        <footer class="mt-4 small muted">
            Generato con Bootstrap + JS puro. I tuoi progressi rimangono in questa pagina (localmente).
        </footer>
    </div>

    <script>
        const state = {
            allQuizzes: [],           // loaded from selected dataset
            wrongQuizzes: [],         // loaded from wrong_quizzes.json
            savedQuizzes: [],         // quiz salvati in corso
            flatPool: [],             // questions for current run
            answers: {},              // qId -> Set of selected indexes
            graded: {},               // qId -> { correct: bool, wrongIndexes: [], missingIndexes: [] }
            order: [],                // sequence of qIds
            choicesOrder: {},         // qId -> array of shuffled choice indexes
            idx: 0,                   // current index within order
            mode: "idle",             // idle|running|finished
            lastRunWrongIds: [],
            currentSetLabel: "",
            availableDatasets: [],    // available quiz files
            currentDataset: "",       // currently loaded dataset
        };

        const el = (id) => document.getElementById(id);
        const setHidden = (node, hidden) => node.classList.toggle("hidden", hidden);

        async function loadAvailableDatasets() {
            // Lista hardcoded dei dataset disponibili (potrebbe essere dinamica in futuro)
            state.availableDatasets = [
                {
                    name: "quizzes_aspetti.json",
                    title: "Aspetti etici e sociali",
                    description: "Domande su aspetti etici e sociali "
                },
                {
                    name: "quizzes_sisbio.json",
                    title: "Sistemi biometrici",
                    description: "Domande su sistemi biometrici"
                },
                {
                    name: "quiz_industrial.json",
                    title: "Industrial Systems",
                    description: "Domande su industrial systems"
                }
            ];

            // Populate dataset dropdown
            populateDatasetDropdown();

            // Seleziona automaticamente il primo dataset
            if (state.availableDatasets.length > 0) {
                const firstDataset = state.availableDatasets[0].name;
                el("datasetSelect").value = firstDataset;
                await loadQuizzes(firstDataset);
            }
        }

        function populateDatasetDropdown() {
            const sel = el("datasetSelect");
            // Pulisci tutte le opzioni esistenti
            sel.innerHTML = "";

            state.availableDatasets.forEach(dataset => {
                const opt = document.createElement("option");
                opt.value = dataset.name;
                opt.textContent = dataset.title;
                sel.appendChild(opt);
            });
        }

        async function loadQuizzes(datasetFile) {
            if (!datasetFile) {
                state.allQuizzes = [];
                state.currentDataset = "";
                populateDropdown();
                updateSetInfo();
                return;
            }

            try {
                const res = await fetch(`quizzes/${datasetFile}`);
                if (!res.ok) {
                    throw new Error(`Errore HTTP! status: ${res.status}`);
                }
                const data = await res.json();
                state.allQuizzes = data.quizzes;
                state.currentDataset = datasetFile;

                // Carica anche le domande sbagliate se esistono
                await loadWrongQuizzes();
                
                // Carica anche i quiz salvati
                await loadSavedQuizzes();

                // Populate dropdown
                populateDropdown();
                updateSetInfo();
                updateDatasetInfo();
            } catch (error) {
                console.error('Errore nel caricamento del dataset:', error);
                alert(`Errore nel caricamento del dataset: ${error.message}`);
                state.allQuizzes = [];
                state.currentDataset = "";
                populateDropdown();
                updateSetInfo();
            }
        }

        function updateDatasetInfo() {
            const dataset = state.availableDatasets.find(d => d.name === state.currentDataset);
            if (dataset) {
                el("datasetInfo").textContent = dataset.description;
            } else {
                el("datasetInfo").textContent = "";
            }
        }

        async function loadWrongQuizzes() {
            try {
                // Prima prova a caricare dal localStorage
                const localData = localStorage.getItem('wrongQuizzes');
                if (localData) {
                    const data = JSON.parse(localData);
                    state.wrongQuizzes = data.quizzes || [];
                    console.log(`Caricati ${state.wrongQuizzes.length} quiz di errori dal localStorage`);
                    return;
                }

                // Se non c'è nulla nel localStorage, prova a caricare dal file
                const res = await fetch("wrong_quizzes.json");
                if (res.ok) {
                    const data = await res.json();
                    state.wrongQuizzes = data.quizzes || [];
                    console.log(`Caricati ${state.wrongQuizzes.length} quiz di errori dal file`);
                }
            } catch (error) {
                // File non esistente o errore di lettura - ignora
                state.wrongQuizzes = [];
                console.log('Nessun file di quiz sbagliati trovato, inizializzazione vuota');
            }
        }

        async function loadSavedQuizzes() {
            try {
                const localData = localStorage.getItem('savedQuizzes');
                if (localData) {
                    const data = JSON.parse(localData);
                    state.savedQuizzes = data.quizzes || [];
                    console.log(`Caricati ${state.savedQuizzes.length} quiz salvati dal localStorage`);
                }
            } catch (error) {
                state.savedQuizzes = [];
                console.log('Nessun quiz salvato trovato');
            }
        }

        function populateDropdown() {
            const sel = el("setSelect");
            // Pulisci le opzioni esistenti tranne "Tutti i quiz"
            while (sel.children.length > 1) {
                sel.removeChild(sel.lastChild);
            }

            // Aggiungi quiz principali
            state.allQuizzes.forEach(qz => {
                const opt = document.createElement("option");
                opt.value = qz.id;
                opt.textContent = qz.title;
                sel.appendChild(opt);
            });

            // Aggiungi il quiz errori unificato se esiste e ha domande
            const errorsQuiz = state.wrongQuizzes.find(q => q.id === 'unified_errors');
            if (errorsQuiz && errorsQuiz.questions.length > 0) {
                const separator = document.createElement("option");
                separator.disabled = true;
                separator.textContent = "— Domande Sbagliate —";
                sel.appendChild(separator);

                const opt = document.createElement("option");
                opt.value = 'unified_errors';
                opt.textContent = `[ERR] Domande Sbagliate (${errorsQuiz.questions.length})`;
                sel.appendChild(opt);
            }

            // Aggiungi i quiz salvati se esistono
            if (state.savedQuizzes.length > 0) {
                const separator = document.createElement("option");
                separator.disabled = true;
                separator.textContent = "— Quiz Salvati —";
                sel.appendChild(separator);

                state.savedQuizzes.forEach(savedQuiz => {
                    const opt = document.createElement("option");
                    opt.value = `saved_${savedQuiz.id}`;
                    opt.textContent = `[SAVE] ${savedQuiz.name} (${savedQuiz.progress}/${savedQuiz.total})`;
                    sel.appendChild(opt);
                });
            }
        }

        async function saveWrongQuestions(wrongQuestions) {
            if (wrongQuestions.length === 0) return;

            // Trova o crea il quiz "Errori" unificato
            let errorsQuiz = state.wrongQuizzes.find(q => q.id === 'unified_errors');

            if (!errorsQuiz) {
                // Crea il quiz errori unificato se non esiste
                errorsQuiz = {
                    id: 'unified_errors',
                    title: 'Domande Sbagliate',
                    questions: []
                };
                state.wrongQuizzes.push(errorsQuiz);
            }

            let addedCount = 0;

            // Aggiungi solo le domande che non sono già presenti
            wrongQuestions.forEach((q, index) => {
                // Controlla se esiste già una domanda con lo stesso testo e quiz originale
                const isDuplicate = errorsQuiz.questions.some(existingQ => 
                    existingQ.text === q.text && existingQ.originalQuiz === q.quizTitle
                );

                if (!isDuplicate) {
                    const newQuestion = {
                        id: `error_${Date.now()}_${index}_${Math.random().toString(36).substr(2, 9)}`,
                        text: q.text,
                        choices: q.choices,
                        correctIndexes: q.correctIndexes,
                        originalQuiz: q.quizTitle // Mantieni traccia del quiz originale
                    };
                    errorsQuiz.questions.push(newQuestion);
                    addedCount++;
                }
            });

            // Aggiorna il localStorage per persistenza
            localStorage.setItem('wrongQuizzes', JSON.stringify({
                lastUpdated: new Date().toISOString(),
                quizzes: state.wrongQuizzes
            }));

            // Aggiorna la dropdown
            populateDropdown();

            if (addedCount > 0) {
                console.log(`${addedCount} nuove domande sbagliate aggiunte al quiz unificato (totale: ${errorsQuiz.questions.length})`);
                if (addedCount < wrongQuestions.length) {
                    console.log(`${wrongQuestions.length - addedCount} domande erano già presenti e sono state saltate per evitare duplicati`);
                }
            } else {
                console.log(`Tutte le ${wrongQuestions.length} domande erano già presenti nei quiz sbagliati`);
            }

            return addedCount; // Ritorna il numero di domande effettivamente aggiunte
        }

        function removeCorrectAnswersFromWrongQuizzes(correctQuestions) {
            if (correctQuestions.length === 0) return 0;

            const errorsQuiz = state.wrongQuizzes.find(q => q.id === 'unified_errors');
            if (!errorsQuiz) return 0;

            let removedCount = 0;
            const initialLength = errorsQuiz.questions.length;

            // Rimuovi le domande che sono state risposte correttamente
            errorsQuiz.questions = errorsQuiz.questions.filter(errorQ => {
                const shouldRemove = correctQuestions.some(correctQ => 
                    correctQ.text === errorQ.text && correctQ.quizTitle === errorQ.originalQuiz
                );
                if (shouldRemove) removedCount++;
                return !shouldRemove;
            });

            // Aggiorna il localStorage se ci sono state rimozioni
            if (removedCount > 0) {
                localStorage.setItem('wrongQuizzes', JSON.stringify({
                    lastUpdated: new Date().toISOString(),
                    quizzes: state.wrongQuizzes
                }));

                // Aggiorna la dropdown
                populateDropdown();
                
                console.log(`${removedCount} domande rimosse dal quiz degli errori (erano state risposte correttamente)`);
            }

            return removedCount;
        }

        function saveCurrentQuiz() {
            if (state.mode !== "running") return;

            const currentSet = el("setSelect").value;
            const quizName = `${state.currentSetLabel} - ${new Date().toLocaleDateString()}`;
            
            const savedQuiz = {
                id: `quiz_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
                name: quizName,
                dataset: state.currentDataset,
                setSelection: currentSet,
                flatPool: state.flatPool,
                answers: Object.fromEntries(
                    Object.entries(state.answers).map(([k, v]) => [k, Array.from(v)])
                ),
                graded: state.graded,
                order: state.order,
                choicesOrder: state.choicesOrder,
                idx: state.idx,
                progress: state.idx + 1,
                total: state.order.length,
                savedAt: new Date().toISOString()
            };

            state.savedQuizzes.push(savedQuiz);

            localStorage.setItem('savedQuizzes', JSON.stringify({
                lastUpdated: new Date().toISOString(),
                quizzes: state.savedQuizzes
            }));

            populateDropdown();
            
            return savedQuiz.name;
        }

        function loadSavedQuiz(savedQuizId) {
            const savedQuiz = state.savedQuizzes.find(q => q.id === savedQuizId);
            if (!savedQuiz) return false;

            // Ripristina lo stato del quiz
            state.flatPool = savedQuiz.flatPool;
            state.answers = Object.fromEntries(
                Object.entries(savedQuiz.answers).map(([k, v]) => [k, new Set(v)])
            );
            state.graded = savedQuiz.graded;
            state.order = savedQuiz.order;
            state.choicesOrder = savedQuiz.choicesOrder;
            state.idx = savedQuiz.idx;
            state.mode = "running";
            state.currentSetLabel = savedQuiz.name;

            // Aggiorna l'UI
            setHidden(el("quizArea"), false);
            setHidden(el("resultArea"), true);
            el("btnPrev").disabled = (state.idx === 0);
            createNavigationBar();
            renderCurrent();

            return true;
        }

        function removeSavedQuiz(savedQuizId) {
            state.savedQuizzes = state.savedQuizzes.filter(q => q.id !== savedQuizId);
            
            localStorage.setItem('savedQuizzes', JSON.stringify({
                lastUpdated: new Date().toISOString(),
                quizzes: state.savedQuizzes
            }));

            populateDropdown();
        }

        function clearSavedQuizzes() {
            const totalSaved = state.savedQuizzes.length;

            if (totalSaved === 0) {
                alert('Non ci sono quiz salvati da cancellare.');
                return;
            }

            if (confirm(`Sei sicuro di voler cancellare tutti i ${totalSaved} quiz salvati?`)) {
                state.savedQuizzes = [];
                localStorage.removeItem('savedQuizzes');
                populateDropdown();
                updateSetInfo();

                const alert = document.createElement("div");
                alert.className = "alert alert-success alert-dismissible fade show mt-2";
                alert.innerHTML = `
          <i class="fas fa-trash"></i> Tutti i ${totalSaved} quiz salvati sono stati cancellati.
          <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
        `;
                el("setInfo").parentElement.appendChild(alert);

                setTimeout(() => {
                    if (alert.parentElement) {
                        alert.parentElement.removeChild(alert);
                    }
                }, 3000);
            }
        }

        function clearWrongQuizzes() {
            const errorsQuiz = state.wrongQuizzes.find(q => q.id === 'unified_errors');
            const totalErrors = errorsQuiz?.questions.length || 0;

            if (totalErrors === 0) {
                alert('Non ci sono domande sbagliate da cancellare.');
                return;
            }

            if (confirm(`Sei sicuro di voler cancellare tutte le ${totalErrors} domande sbagliate?`)) {
                state.wrongQuizzes = [];
                localStorage.removeItem('wrongQuizzes');
                populateDropdown();
                updateSetInfo();

                const alert = document.createElement("div");
                alert.className = "alert alert-success alert-dismissible fade show mt-2";
                alert.innerHTML = `
          <i class="fas fa-trash"></i> Tutte le ${totalErrors} domande sbagliate sono state cancellate.
          <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
        `;
                el("setInfo").parentElement.appendChild(alert);

                setTimeout(() => {
                    if (alert.parentElement) {
                        alert.parentElement.removeChild(alert);
                    }
                }, 3000);
            }
        }

        function updateSetInfo() {
            const selVal = el("setSelect").value;
            let total = 0;
            if (selVal === "all") {
                state.allQuizzes.forEach(qz => total += qz.questions.length);
                el("setInfo").textContent = `Tutti i quiz uniti • ${total} domande`;
                state.currentSetLabel = "Tutti i quiz";
            } else if (selVal === "unified_errors") {
                // Quiz errori unificato
                const errorsQuiz = state.wrongQuizzes.find(q => q.id === 'unified_errors');
                total = errorsQuiz?.questions.length || 0;
                el("setInfo").textContent = `Domande sbagliate da tutti i quiz • ${total} domande`;
                state.currentSetLabel = "Domande Sbagliate";
            } else if (selVal.startsWith("saved_")) {
                // Quiz salvato
                const savedQuizId = selVal.replace("saved_", "");
                const savedQuiz = state.savedQuizzes.find(q => q.id === savedQuizId);
                if (savedQuiz) {
                    el("setInfo").textContent = `Quiz salvato • Progresso: ${savedQuiz.progress}/${savedQuiz.total} domande`;
                    state.currentSetLabel = savedQuiz.name;
                    total = savedQuiz.total;
                }
            } else {
                // Quiz normale
                const qz = state.allQuizzes.find(q => q.id === selVal);
                total = qz?.questions.length || 0;
                el("setInfo").textContent = `${qz?.title || ""} • ${total} domande`;
                state.currentSetLabel = qz?.title || "";
            }
            el("totalCounter").textContent = `${total} domande`;
        }

        function buildPool(selVal) {
            const pool = [];
            if (selVal === "all") {
                state.allQuizzes.forEach(qz => {
                    qz.questions.forEach(q => pool.push({ ...q, quizTitle: qz.title }));
                });
            } else if (selVal === "unified_errors") {
                // Quiz errori unificato
                const errorsQuiz = state.wrongQuizzes.find(q => q.id === 'unified_errors');
                if (errorsQuiz) {
                    errorsQuiz.questions.forEach(q => pool.push({
                        ...q,
                        quizTitle: q.originalQuiz || "Errori" // Usa il quiz originale se disponibile
                    }));
                }
            } else if (selVal.startsWith("saved_")) {
                // Quiz salvato - non usare buildPool, sarà gestito diversamente
                return [];
            } else {
                // Quiz normale
                const qz = state.allQuizzes.find(q => q.id === selVal);
                if (qz) {
                    qz.questions.forEach(q => pool.push({ ...q, quizTitle: qz.title }));
                }
            }
            return pool;
        }

        function startRun(fromWrong = false) {
            state.answers = {};
            state.graded = {};
            state.choicesOrder = {}; // Reset dell'ordine delle scelte
            state.idx = 0;
            state.mode = "running";

            if (fromWrong) {
                // build pool from last wrong ids
                const idset = new Set(state.lastRunWrongIds);
                const pool = [];
                state.allQuizzes.forEach(qz => {
                    qz.questions.forEach(q => { if (idset.has(q.id)) pool.push({ ...q, quizTitle: qz.title }); });
                });
                state.flatPool = pool;
                state.order = pool.map(q => q.id);

                // Applica shuffle anche per ripasso errori se l'opzione è selezionata
                if (el("shuffleCheckbox").checked) {
                    // Shuffle Fisher-Yates
                    for (let i = state.order.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [state.order[i], state.order[j]] = [state.order[j], state.order[i]];
                    }
                }

                state.currentSetLabel = "Ripasso errori";
            } else {
                const selVal = el("setSelect").value;
                state.flatPool = buildPool(selVal);
                state.order = state.flatPool.map(q => q.id);

                // Applica shuffle se l'opzione è selezionata
                if (el("shuffleCheckbox").checked) {
                    // Shuffle Fisher-Yates
                    for (let i = state.order.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [state.order[i], state.order[j]] = [state.order[j], state.order[i]];
                    }
                }
            }

            // Pre-genera l'ordine shufflato delle scelte per ogni domanda
            state.flatPool.forEach(q => {
                const choicesIndexes = Array.from({ length: q.choices.length }, (_, i) => i);
                // Shuffle Fisher-Yates per le scelte
                for (let i = choicesIndexes.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [choicesIndexes[i], choicesIndexes[j]] = [choicesIndexes[j], choicesIndexes[i]];
                }
                state.choicesOrder[q.id] = choicesIndexes;
            });

            setHidden(el("quizArea"), false);
            setHidden(el("resultArea"), true);
            el("btnPrev").disabled = true;
            createNavigationBar();
            renderCurrent();
        }

        function getCurrent() {
            const id = state.order[state.idx];
            return state.flatPool.find(q => q.id === id);
        }

        function createNavigationBar() {
            const container = el("questionNumbers");
            container.innerHTML = "";

            // Crea i numeri per ogni domanda
            state.order.forEach((questionId, index) => {
                const button = document.createElement("button");
                button.className = "btn question-number";
                button.textContent = index + 1;
                button.title = `Vai alla domanda ${index + 1}`;

                // Gestisci il click per navigare
                button.addEventListener("click", () => {
                    // Prima di spostarsi, valuta la domanda corrente se ha una risposta
                    const currentQ = getCurrent();
                    if (currentQ && state.answers[currentQ.id] && state.answers[currentQ.id].size > 0) {
                        const g = gradeQuestion(currentQ);
                        showGradeOnUI(currentQ, g);
                    }
                    
                    state.idx = index;
                    renderCurrent();
                    updateNavigationBar();
                    
                    // Scroll per rendere visibile il bottone corrente
                    setTimeout(() => {
                        const container = document.querySelector('.navigation-container');
                        const grid = el("questionNumbers");
                        if (button && container && grid) {
                            // Calcola quante colonne ci sono nella griglia
                            const gridStyles = window.getComputedStyle(grid);
                            const gridTemplateColumns = gridStyles.gridTemplateColumns.split(' ').length;
                            
                            // Trova l'indice del bottone cliccato
                            const buttonIndex = Array.from(grid.children).indexOf(button);
                            
                            // Calcola la riga del bottone (base 0)
                            const buttonRow = Math.floor(buttonIndex / gridTemplateColumns);
                            
                            // Altezza di una riga (altezza bottone + gap)
                            const buttonHeight = button.offsetHeight;
                            const gap = parseInt(gridStyles.gap) || 4;
                            const rowHeight = buttonHeight + gap;
                            
                            // Posizione Y del centro della riga (relativa alla griglia)
                            const rowCenterY = (buttonRow * rowHeight) + (buttonHeight / 2);
                            
                            // Considera il padding del container
                            const containerStyles = window.getComputedStyle(container);
                            const paddingTop = parseInt(containerStyles.paddingTop) || 0;
                            
                            // Centra quella riga nel container
                            const containerHeight = container.clientHeight;
                            const scrollPosition = rowCenterY + paddingTop - (containerHeight / 2);
                            
                            // Usa scrollTo con behavior smooth
                            container.scrollTo({
                                top: Math.max(0, scrollPosition),
                                behavior: 'smooth'
                            });
                        }
                    }, 100);
                });

                container.appendChild(button);
            });

            updateNavigationBar();
        }

        function updateNavigationBar() {
            const buttons = el("questionNumbers").querySelectorAll(".question-number");
            const showErrors = el("showErrorsCheckbox").checked;

            buttons.forEach((button, index) => {
                const questionId = state.order[index];

                // Reset classi
                button.classList.remove("current", "answered", "correct", "wrong");

                // Aggiungi classe current per la domanda attuale
                if (index === state.idx) {
                    button.classList.add("current");
                }

                // Controlla se la domanda è stata risposta
                if (state.answers[questionId] && state.answers[questionId].size > 0) {
                    button.classList.add("answered");

                    // Se è stata anche controllata e l'opzione "mostra errori" è attiva
                    if (state.graded[questionId] !== undefined && showErrors) {
                        // Rimuovi "answered" e aggiungi "correct" o "wrong"
                        button.classList.remove("answered");
                        if (state.graded[questionId].correct) {
                            button.classList.add("correct");
                        } else {
                            button.classList.add("wrong");
                        }
                    }
                }
            });
        }

        function renderCurrent() {
            const q = getCurrent();
            el("qText").innerHTML = q.text;
            el("quizBadge").textContent = q.quizTitle;
            el("progressLabel").textContent = `Domanda ${state.idx + 1} / ${state.order.length}`;
            el("progressBar").style.width = `${((state.idx + 1) / state.order.length) * 100}%`;

            const multiple = (q.correctIndexes.length > 1);
            const choicesDiv = el("choices");
            choicesDiv.innerHTML = "";

            // Usa l'ordine pre-generato delle scelte per questa domanda
            const shuffledIndexes = state.choicesOrder[q.id] || Array.from({ length: q.choices.length }, (_, i) => i);

            shuffledIndexes.forEach((originalIdx, displayIdx) => {
                const ch = q.choices[originalIdx];
                const wrap = document.createElement("div");
                wrap.className = "card choice";
                const body = document.createElement("div");
                body.className = "card-body py-2";

                const input = document.createElement("input");
                input.type = multiple ? "checkbox" : "radio";
                input.className = "form-check-input";
                input.name = multiple ? `checkbox_${q.id}` : `radio_${q.id}`;
                input.id = `ch_${displayIdx}`;
                input.value = originalIdx; // Usa l'indice originale come valore

                // Controlla se questa risposta è già selezionata (usando l'indice originale)
                const isSelected = state.answers[q.id] && state.answers[q.id].has(originalIdx);
                input.checked = isSelected;

                const label = document.createElement("label");
                label.className = "form-check-label";
                label.setAttribute("for", `ch_${displayIdx}`);
                label.textContent = ch.text;

                // Event listener semplificato
                input.addEventListener("change", () => {
                    if (!state.answers[q.id]) {
                        state.answers[q.id] = new Set();
                    }
                    if (multiple) {
                        if (input.checked) {
                            state.answers[q.id].add(originalIdx);
                        } else {
                            state.answers[q.id].delete(originalIdx);
                        }
                    } else {
                        state.answers[q.id] = new Set([originalIdx]);
                    }
                    if (state.graded[q.id] !== undefined) {
                        delete state.graded[q.id];
                        document.querySelectorAll(".choice").forEach(card => {
                            card.classList.remove("correct", "wrong");
                        });
                    }
                    updateNavigationBar();
                });

                // Rende cliccabile tutta la card (anche sui bordi)
                wrap.addEventListener("click", (e) => {
                    // Evita doppio trigger se si clicca direttamente sull'input
                    if (e.target === input) return;
                    input.checked = multiple ? !input.checked : true;
                    input.dispatchEvent(new Event("change", { bubbles: true }));
                });

                body.appendChild(input);
                body.appendChild(label);
                wrap.appendChild(body);
                choicesDiv.appendChild(wrap);
            });

            // Reset grading visuals
            Array.from(document.querySelectorAll(".choice")).forEach(c => {
                c.classList.remove("correct", "wrong");
            });

                // Evidenzia direttamente la risposta se la checkbox è attiva
                if (el("highlightAnswerCheckbox") && el("highlightAnswerCheckbox").checked) {
                    // Evidenzia tutte le scelte corrette
                    const q = getCurrent();
                    const choicesDiv = el("choices");
                    Array.from(choicesDiv.children).forEach((wrap, idx) => {
                        // wrap = .card.choice
                        // Trova l'indice originale della scelta
                        const input = wrap.querySelector("input");
                        if (input && q.correctIndexes.includes(parseInt(input.value))) {
                            wrap.classList.add("correct");
                        }
                    });
                }

                // Aggiorna la visualizzazione quando la checkbox cambia
                if (el("highlightAnswerCheckbox")) {
                    el("highlightAnswerCheckbox").onchange = () => renderCurrent();
                }
            // Buttons
            el("btnPrev").disabled = (state.idx === 0);
            el("btnNext").textContent = (state.idx === state.order.length - 1) ? "Consegna" : "Next";

            updateNavigationBar();
            
            // Auto-scroll per centrare il numero corrente nella navbar
            setTimeout(() => {
                const currentButton = el("questionNumbers").children[state.idx];
                const container = document.querySelector('.navigation-container');
                const grid = el("questionNumbers");
                if (currentButton && container && grid) {
                    // Calcola quante colonne ci sono nella griglia
                    const gridStyles = window.getComputedStyle(grid);
                    const gridTemplateColumns = gridStyles.gridTemplateColumns.split(' ').length;
                    
                    // Calcola la riga del bottone corrente (base 0)
                    const buttonRow = Math.floor(state.idx / gridTemplateColumns);
                    
                    // Altezza di una riga (altezza bottone + gap)
                    const buttonHeight = currentButton.offsetHeight;
                    const gap = parseInt(gridStyles.gap) || 4;
                    const rowHeight = buttonHeight + gap;
                    
                    // Posizione Y del centro della riga (relativa alla griglia)
                    const rowCenterY = (buttonRow * rowHeight) + (buttonHeight / 2);
                    
                    // Considera il padding del container
                    const containerStyles = window.getComputedStyle(container);
                    const paddingTop = parseInt(containerStyles.paddingTop) || 0;
                    
                    // Centra quella riga nel container
                    const containerHeight = container.clientHeight;
                    const scrollPosition = rowCenterY + paddingTop - (containerHeight / 2);
                    
                    // Usa scrollTo con behavior smooth
                    container.scrollTo({
                        top: Math.max(0, scrollPosition),
                        behavior: 'smooth'
                    });
                }
            }, 100);

            // Posizionamento intelligente su mobile
            smartMobilePosition();
        }

        function smartMobilePosition() {
            // Controlla se siamo su mobile (schermo piccolo)
            if (window.innerWidth > 768) return; // Solo su mobile

            setTimeout(() => {
                const quizArea = el("quizArea");
                const navigationBar = el("navigationBar");
                const questionCard = el("questionCard");
                const stickyFooter = document.querySelector(".sticky-footer");
                
                if (!quizArea || !questionCard || !stickyFooter) return;

                // Calcola l'altezza della footer sticky
                const footerHeight = stickyFooter.offsetHeight;
                
                // Calcola l'altezza totale necessaria
                const navBarHeight = navigationBar ? navigationBar.offsetHeight : 0;
                const questionCardHeight = questionCard.offsetHeight;
                const totalContentHeight = navBarHeight + questionCardHeight + 60; // +60 per margini

                // Altezza viewport disponibile (sottraendo la footer sticky)
                const availableHeight = window.innerHeight - footerHeight;

                if (totalContentHeight <= availableHeight) {
                    // Contenuto corto: posiziona la domanda in modo che non sia coperta dalla footer
                    // Calcola la posizione che lascia spazio per la footer
                    const targetPosition = window.innerHeight - questionCardHeight - footerHeight - 20; // -20 per margine
                    
                    window.scrollTo({
                        top: Math.max(0, questionCard.offsetTop - targetPosition),
                        behavior: 'smooth'
                    });
                } else {
                    // Contenuto lungo: posiziona la domanda in alto
                    questionCard.scrollIntoView({ 
                        behavior: 'smooth', 
                        block: 'start',
                        inline: 'nearest'
                    });
                }
            }, 150); // Timeout per permettere il rendering del contenuto
        }

        function gradeQuestion(q) {
            const selected = Array.from(state.answers[q.id] || new Set()).sort((a, b) => a - b);
            const correct = q.correctIndexes.slice().sort((a, b) => a - b);
            const selSet = new Set(selected);
            const corrSet = new Set(correct);
            const wrongIndexes = selected.filter(i => !corrSet.has(i));
            const missingIndexes = correct.filter(i => !selSet.has(i));
            const isCorrect = wrongIndexes.length === 0 && missingIndexes.length === 0;

            state.graded[q.id] = { correct: isCorrect, wrongIndexes, missingIndexes };
            return state.graded[q.id];
        }

        function showGradeOnUI(q, g) {
            // Mark wrong/correct choices based on their original indexes
            const cards = document.querySelectorAll(".choice");
            cards.forEach((card, displayIdx) => {
                const input = card.querySelector("input");
                const originalIdx = parseInt(input.value); // L'indice originale è salvato nel value

                if (g.wrongIndexes.includes(originalIdx)) card.classList.add("wrong");
                if (g.missingIndexes.includes(originalIdx) || q.correctIndexes.includes(originalIdx)) {
                    // highlight corrects so user sees the solution
                    card.classList.add("correct");
                }
            });
        }

        function nextOrFinish() {
            if (state.idx < state.order.length - 1) {
                state.idx += 1;
                renderCurrent();
            } else {
                finishRun();
            }
        }

        async function finishRun() {
            state.mode = "finished";
            
            // Se questo era un quiz salvato, rimuovilo dai quiz salvati
            const currentSelection = el("setSelect").value;
            if (currentSelection.startsWith("saved_")) {
                const savedQuizId = currentSelection.replace("saved_", "");
                removeSavedQuiz(savedQuizId);
            }
            
            // compute totals
            const total = state.order.length;
            let correctCount = 0;
            const wrongIds = [];
            const wrongQuestions = [];
            const correctQuestions = [];

            state.flatPool.forEach(q => {
                const g = state.graded[q.id] || gradeQuestion(q);
                if (g.correct) {
                    correctCount += 1;
                    correctQuestions.push(q);
                } else {
                    // Aggiungi tra le sbagliate SOLO se l'utente ha risposto (cioè ha selezionato almeno una risposta)
                    const answered = state.answers[q.id] && state.answers[q.id].size > 0;
                    if (answered) {
                        wrongIds.push(q.id);
                        wrongQuestions.push(q);
                    }
                }
            });

            state.lastRunWrongIds = wrongIds;

            // Se stiamo facendo il ripasso delle domande sbagliate, rimuovi quelle corrette
            let removedCorrectCount = 0;
            const isReviewingErrors = el("setSelect").value === 'unified_errors';
            if (isReviewingErrors && correctQuestions.length > 0) {
                removedCorrectCount = removeCorrectAnswersFromWrongQuizzes(correctQuestions);
            }

            // Salva le domande sbagliate se ce ne sono (solo se non stiamo ripassando errori)
            let addedWrongCount = 0;
            if (wrongQuestions.length > 0 && !isReviewingErrors) {
                addedWrongCount = await saveWrongQuestions(wrongQuestions);
            }

            // UI update
            setHidden(el("quizArea"), true);
            setHidden(el("resultArea"), false);
            el("resultSummary").innerHTML = `<strong>Punteggio:</strong> ${correctCount}/${total} corrette`;

            // Messaggi per il ripasso delle domande sbagliate
            if (isReviewingErrors && removedCorrectCount > 0) {
                const removeMsg = document.createElement("div");
                removeMsg.className = "alert alert-success mt-2";
                removeMsg.innerHTML = `<i class="fas fa-trophy"></i> ${removedCorrectCount} ${removedCorrectCount === 1 ? 'domanda rimossa' : 'domande rimosse'} dai "Quiz Sbagliati" (risposte corrette!)`;
                el("resultSummary").appendChild(removeMsg);
            }

            // Aggiungi messaggio per le domande sbagliate salvate (solo per quiz normali)
            if (!isReviewingErrors) {
                if (addedWrongCount > 0) {
                    const saveMsg = document.createElement("div");
                    saveMsg.className = "alert alert-success mt-2";
                    saveMsg.innerHTML = `<i class="fas fa-save"></i> ${addedWrongCount} ${addedWrongCount === 1 ? 'nuova domanda sbagliata aggiunta' : 'nuove domande sbagliate aggiunte'} ai "Quiz Sbagliati"`;
                    if (addedWrongCount < wrongQuestions.length) {
                        saveMsg.innerHTML += ` (${wrongQuestions.length - addedWrongCount} erano già presenti)`;
                    }
                    el("resultSummary").appendChild(saveMsg);
                } else if (wrongQuestions.length > 0) {
                    const saveMsg = document.createElement("div");
                    saveMsg.className = "alert alert-info mt-2";
                    saveMsg.innerHTML = `<i class="fas fa-info-circle"></i> Tutte le ${wrongQuestions.length} domande sbagliate erano già presenti nei "Quiz Sbagliati"`;
                    el("resultSummary").appendChild(saveMsg);
                }
            }

            const review = el("reviewList");
            review.innerHTML = "";

            // Usa l'ordine dello shuffle se presente, altrimenti l'ordine originale
            const reviewOrder = state.order || state.flatPool.map(q => q.id);

            reviewOrder.forEach((questionId, index) => {
                const q = state.flatPool.find(question => question.id === questionId);
                if (!q) return; // Sicurezza

                const g = state.graded[q.id];
                const selectedAnswers = state.answers[q.id] || new Set();
                const hasAnswered = selectedAnswers.size > 0;

                const item = document.createElement("div");
                item.className = "card";
                
                // Se non ha risposto, rendi la card collassabile
                if (!hasAnswered) {
                    const cardHeader = document.createElement("div");
                    cardHeader.className = "card-header";
                    cardHeader.style.cursor = "pointer";
                    cardHeader.setAttribute("data-bs-toggle", "collapse");
                    cardHeader.setAttribute("data-bs-target", `#collapse-${index}`);
                    cardHeader.setAttribute("aria-expanded", "false");
                    cardHeader.setAttribute("aria-controls", `collapse-${index}`);
                    
                    cardHeader.innerHTML = `
                        <div class="d-flex justify-content-between align-items-center">
                            <span>
                                <span class="badge me-2 bg-warning text-dark">NON RISPOSTA</span> 
                                <span class="muted">${q.quizTitle} - Domanda ${index + 1}</span>
                            </span>
                            <span class="collapse-icon">▼</span>
                        </div>
                    `;
                    
                    item.appendChild(cardHeader);
                    
                    const collapseDiv = document.createElement("div");
                    collapseDiv.className = "collapse";
                    collapseDiv.id = `collapse-${index}`;
                    
                    const b = document.createElement("div");
                    b.className = "card-body";
                    
                    const text = document.createElement("div");
                    text.className = "question-text my-2";
                    text.innerHTML = q.text;
                    
                    b.appendChild(text);
                    collapseDiv.appendChild(b);
                    item.appendChild(collapseDiv);
                } else {
                    // Domanda con risposta (corretta o sbagliata) - mantieni il layout normale
                    const b = document.createElement("div");
                    b.className = "card-body";

                    const title = document.createElement("div");
                    title.innerHTML = `<span class="badge me-2 ${g.correct ? "bg-success" : "bg-danger"}">${g.correct ? "OK" : "ERR"}</span> <span class="muted">${q.quizTitle} - Domanda ${index + 1}</span>`;

                    const text = document.createElement("div");
                    text.className = "question-text my-2";
                    text.innerHTML = q.text; // Usa innerHTML per supportare immagini

                    b.appendChild(title);
                    b.appendChild(text);
                    item.appendChild(b);
                }

                // Continua il contenuto solo per le domande con risposta
                if (hasAnswered) {
                    const b = item.querySelector('.card-body'); // Prendi il card-body già creato sopra
                    
                    if (g.correct) {
                        // Se la risposta è corretta, mostra solo la soluzione
                        const sol = document.createElement("div");
                        sol.className = "small text-success";
                        const correctTexts = q.correctIndexes.map(i => q.choices[i].text);
                        sol.innerHTML = `<em><i class="fas fa-check"></i> Risposta corretta:</em> ${correctTexts.join(" • ")}`;
                        b.appendChild(sol);
                    } else {
                        // Se la risposta è sbagliata, mostra tutte le opzioni con evidenziazione
                        const allChoicesDiv = document.createElement("div");
                        allChoicesDiv.className = "mt-3";

                        const choicesTitle = document.createElement("div");
                        choicesTitle.className = "small fw-bold mb-2";
                        choicesTitle.textContent = "Tutte le risposte:";
                        allChoicesDiv.appendChild(choicesTitle);

                        q.choices.forEach((choice, index) => {
                            const choiceDiv = document.createElement("div");
                            choiceDiv.className = "d-flex align-items-center mb-1 p-2 rounded";

                            const isCorrect = q.correctIndexes.includes(index);
                            const isSelected = selectedAnswers.has(index);

                            // Styling basato su stato
                            if (isCorrect && isSelected) {
                                choiceDiv.style.backgroundColor = "#d1e7dd"; // Verde chiaro - corretta e selezionata
                                choiceDiv.style.border = "1px solid #198754";
                            } else if (isCorrect) {
                                choiceDiv.style.backgroundColor = "#e6f4ea"; // Verde molto chiaro - corretta ma non selezionata
                                choiceDiv.style.border = "1px solid #198754";
                            } else if (isSelected) {
                                choiceDiv.style.backgroundColor = "#f8d7da"; // Rosso chiaro - sbagliata e selezionata
                                choiceDiv.style.border = "1px solid #dc3545";
                            } else {
                                choiceDiv.style.backgroundColor = "#f8f9fa"; // Grigio - né corretta né selezionata
                                choiceDiv.style.border = "1px solid #dee2e6";
                            }

                            // Icone
                            let icon = "";
                            if (isCorrect && isSelected) {
                                icon = "✓ "; // Corretta e selezionata
                            } else if (isCorrect) {
                                icon = "✓ "; // Corretta
                            } else if (isSelected) {
                                icon = "✗ "; // Sbagliata e selezionata
                            } else {
                                icon = "○ "; // Non selezionata
                            }

                            choiceDiv.innerHTML = `<span class="me-2">${icon}</span><span>${choice.text}</span>`;
                            allChoicesDiv.appendChild(choiceDiv);
                        });

                        b.appendChild(allChoicesDiv);
                    }
                } else {
                    // Per le domande senza risposta, aggiungi il contenuto nel div collassabile
                    const collapseContent = item.querySelector('.card-body');
                    
                    // Mostra tutte le opzioni con la risposta corretta evidenziata
                    const allChoicesDiv = document.createElement("div");
                    allChoicesDiv.className = "mt-3";

                    const choicesTitle = document.createElement("div");
                    choicesTitle.className = "small fw-bold mb-2";
                    choicesTitle.textContent = "Tutte le risposte:";
                    allChoicesDiv.appendChild(choicesTitle);

                    q.choices.forEach((choice, index) => {
                        const choiceDiv = document.createElement("div");
                        choiceDiv.className = "d-flex align-items-center mb-1 p-2 rounded";

                        const isCorrect = q.correctIndexes.includes(index);

                        // Styling per domande non risposte
                        if (isCorrect) {
                            choiceDiv.style.backgroundColor = "#e6f4ea"; // Verde chiaro - risposta corretta
                            choiceDiv.style.border = "1px solid #198754";
                        } else {
                            choiceDiv.style.backgroundColor = "#f8f9fa"; // Grigio neutro
                            choiceDiv.style.border = "1px solid #dee2e6";
                        }

                        const icon = isCorrect ? "✓ " : "○ ";
                        choiceDiv.innerHTML = `<span class="me-2">${icon}</span><span>${choice.text}</span>`;
                        allChoicesDiv.appendChild(choiceDiv);
                    });

                    collapseContent.appendChild(allChoicesDiv);
                }

                review.appendChild(item);
            });
        }

        // Event listeners
        el("setSelect").addEventListener("change", updateSetInfo);
        el("btnStart").addEventListener("click", () => {
            if (!state.currentDataset) {
                alert("Seleziona prima un dataset di quiz!");
                return;
            }
            
            const selVal = el("setSelect").value;
            if (selVal.startsWith("saved_")) {
                // Carica quiz salvato
                const savedQuizId = selVal.replace("saved_", "");
                if (loadSavedQuiz(savedQuizId)) {
                    console.log("Quiz salvato caricato con successo");
                } else {
                    alert("Errore nel caricamento del quiz salvato");
                }
            } else {
                // Inizia nuovo quiz
                startRun(false);
            }
        });
        el("btnClearSaved").addEventListener("click", clearSavedQuizzes);
        el("btnClearWrong").addEventListener("click", clearWrongQuizzes);
        el("btnHelp").addEventListener("click", () => {
            const helpModal = new bootstrap.Modal(document.getElementById('helpModal'));
            helpModal.show();
        });
        el("btnSave").addEventListener("click", () => {
            if (state.mode !== "running") {
                alert("Non c'è un quiz in corso da salvare!");
                return;
            }
            
            const savedName = saveCurrentQuiz();
            alert(`Quiz salvato come: ${savedName}`);
            
            // Torna alla schermata principale
            state.mode = "idle";
            setHidden(el("quizArea"), true);
            setHidden(el("resultArea"), true);
        });
        el("btnPrev").addEventListener("click", () => {
            if (state.idx > 0) { state.idx -= 1; renderCurrent(); }
        });
        el("btnNext").addEventListener("click", () => {
            if (state.idx === state.order.length - 1) {
                // final click is "Consegna" – grade current then finish
                const q = getCurrent();
                const g = gradeQuestion(q);
                showGradeOnUI(q, g);
                setTimeout(finishRun, 0); // Aumentato a 1 secondo
            } else {
                const q = getCurrent();
                const g = gradeQuestion(q);
                showGradeOnUI(q, g);
                setTimeout(nextOrFinish, 0); // Aumentato a 1 secondo
            }
        });
        el("btnCheck").addEventListener("click", () => {
            const q = getCurrent();
            const g = gradeQuestion(q);
            showGradeOnUI(q, g);
            updateNavigationBar(); // Aggiorna la barra per mostrare se la risposta è corretta/sbagliata
            // Mantieni la visualizzazione per 1 secondo prima di permettere altre azioni
            setTimeout(() => {
                // Potresti aggiungere qui logica aggiuntiva se necessaria
            }, 1000);
        });

        // Event listener per la selezione del dataset
        el("datasetSelect").addEventListener("change", (e) => {
            const selectedDataset = e.target.value;
            loadQuizzes(selectedDataset);
        });

        // Event listener per il checkbox "Mostra errori"
        el("showErrorsCheckbox").addEventListener("change", () => {
            updateNavigationBar();
        });

        // Event listener per il tasto Invio
        document.addEventListener("keydown", (e) => {
            // Verifica che non ci siano modificatori premuti (ctrl, alt, shift, meta)
            if (e.ctrlKey || e.altKey || e.shiftKey || e.metaKey) {
                return; // Non fare nulla se ci sono modificatori
            }

            if (e.key === "n" && state.mode === "running") {
                e.preventDefault();
                // Simula il click del bottone "Avanti/Consegna"
                el("btnNext").click();
            };
            if (e.key === "c" && state.mode === "running") {
                e.preventDefault();
                // Simula il click del bottone "Controlla"
                el("btnCheck").click();
            };
            if (e.key === "p" && state.mode === "running") {
                e.preventDefault();
                // Simula il click del bottone "Indietro"
                el("btnPrev").click();
            }
            if (e.key === "1" && state.mode === "running") {
                e.preventDefault();
                // Seleziona la prima scelta
                const firstChoice = document.querySelector(".choice input");
                if (firstChoice) firstChoice.click();
            }
            if (e.key === "2" && state.mode === "running") {
                e.preventDefault();
                // Seleziona la seconda scelta
                const secondChoice = document.querySelectorAll(".choice input")[1];
                if (secondChoice) secondChoice.click();
            }
            if (e.key === "3" && state.mode === "running") {
                e.preventDefault();
                // Seleziona la terza scelta
                const thirdChoice = document.querySelectorAll(".choice input")[2];
                if (thirdChoice) thirdChoice.click();
            }
            if (e.key === "4" && state.mode === "running") {
                e.preventDefault();
                // Seleziona la quarta scelta
                const fourthChoice = document.querySelectorAll(".choice input")[3];
                if (fourthChoice) fourthChoice.click();
            }
        });

        // Inizializzazione
        loadAvailableDatasets();
        
        // Inizializza i tooltip Bootstrap
        const tooltipTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle="tooltip"]'));
        const tooltipList = tooltipTriggerList.map(function (tooltipTriggerEl) {
            return new bootstrap.Tooltip(tooltipTriggerEl);
        });
    </script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>
</body>

</html>
